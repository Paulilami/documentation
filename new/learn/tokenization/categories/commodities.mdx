---
title: "Commodities"
description: "Physical asset tokenization with automated reserve verification and flexible redemption"
---

Commodity Tokens bridge physical assets and blockchain rails through programmable reserve attestation and multi-modal redemption. Lock physical commodities in verified vaults, issue tokens backed by real-time reserve proofs, and enable instant settlement across primary and secondary markets.

## Why Institutions Tokenize Commodities

<CardGroup cols={2}>
    <Card title="Eliminate Intermediaries" icon="link-slash">
        Remove custodians, transfer agents, and settlement intermediaries with on-chain verification
    </Card>
    <Card title="Instant Liquidity" icon="droplet">
        Transform illiquid physical assets into tradable collateral with 24/7 market access
    </Card>
    <Card title="Automated Compliance" icon="shield-check">
        Reserve ratios validate on-chain before every mint, preventing over-issuance automatically
    </Card>
    <Card title="Flexible Redemption" icon="arrows-rotate">
        Support physical delivery, cash settlement, or unit-based redemption based on asset requirements
    </Card>
</CardGroup>

## Reserve Management

Issuers maintain physical commodity reserves in verified vaults and publish attestations on-chain. Each token locks to a fixed `gramsPerToken` ratio established at deployment—for gold, this might be 1 gram per token. The contract validates that `totalSupply × gramsPerToken ≤ totalGramsReserve × 10^18` before executing any mint operation.

Reserve attestations point to third-party audit reports, vault certifications, or quality grading documentation through IPFS URIs or similar content-addressed storage. Issuers update these attestations as new audits complete without requiring contract redeployment. The `vaultLocationHash` provides cryptographic verification of physical storage locations while maintaining operational security.

<Accordion title="Reserve Validation Example">
Consider a gold token with `gramsPerToken = 1e18` (1 gram per token):

```solidity
// Issuer attempts to mint 1000 tokens
totalSupply = 5000 tokens
gramsPerToken = 1e18
totalGramsReserve = 6500 grams

// Validation check
requiredGrams = (5000 + 1000) × 1e18 / 1e18 = 6000 grams
actualReserve = 6500 grams

// Result: Mint approved (6500 >= 6000)
```

If the issuer tries minting 2000 tokens instead, the transaction reverts because the reserve would be insufficient (6500 < 7000).
</Accordion>

## Sub-Issuer Architecture

Multiple financial institutions can issue tokens against the same commodity type through the factory deployment pattern. Each institution becomes a sub-issuer with independent mint limits, fee structures, and redemption processes—but all tokens share the same contract implementation.

| Single Issuer Model | Sub-Issuer Model |
|---------------------|------------------|
| One institution controls all minting | Multiple authorized issuers mint independently |
| Centralized reserve management | Each sub-issuer maintains separate reserves |
| Single point of failure | Distributed issuance reduces systemic risk |
| Limited liquidity pools | Combined liquidity across all sub-issuers |

Sub-issuers configure their own `mintLimit` caps that prevent any single institution from dominating supply. The main issuer approves sub-issuer applications and can revoke minting privileges if reserve compliance fails. This creates a federated model where multiple banks or exchanges can offer the same commodity token while maintaining independent operations.

## Redemption Modes

Commodity Tokens support three distinct redemption patterns that accommodate different asset types and regulatory requirements:

<Tabs>
    <Tab title="Physical Delivery">
        Users burn tokens to receive physical commodity units. The contract enforces minimum redemption amounts through `minTokensForAsset` to match standard unit sizes (e.g., 1kg gold bars require at least 1000 tokens if each represents 1 gram).

        When `unitsEnabled = true` and `unitWeightGrams` is set, redemptions must align to physical unit boundaries. Attempting to redeem 1500 grams when units are 1000 grams will revert—users must burn multiples of the unit size.

        ```typescript
        // User requests physical gold delivery
        await commodityToken.createBurnRequest(
            1000e18, // 1000 tokens = 1000 grams = 1 bar
            true,    // burnTokens = physical redemption
            RequestType.MANUAL_APPROVAL,
            0
        );
        // Tokens locked pending issuer fulfillment
        // After verification, issuer ships physical gold
        // Request executed, tokens burned, reserve decremented
        ```
    </Tab>
    
    <Tab title="Cash Settlement">
        Users redeem tokens for USDC at current market prices without physical delivery. This mode requires `cashRedemptionEnabled = true` and sufficient USDC liquidity in the contract.

        The contract queries `priceURI` for current pricing data, calculates the USDC equivalent, and transfers stablecoins directly to the user. Tokens burn but the physical reserve remains intact—enabling fractional ownership without requiring commodity divisibility.

        ```typescript
        // User requests cash redemption
        await commodityToken.createBurnRequest(
            500e18,  // 500 tokens worth of commodity
            false,   // burnTokens = cash settlement
            RequestType.INSTANT,
            0
        );
        // Contract calculates USDC value from priceURI
        // Transfers USDC to user immediately
        // Burns tokens, reserve stays unchanged
        ```
    </Tab>
    
    <Tab title="Hybrid Approach">
        Issuers can enable both modes simultaneously, letting users choose based on their needs. Investors seeking exposure without storage concerns use cash settlement. Users requiring physical possession for industrial use or long-term holding request delivery.

        The contract tracks locked balances separately during redemption processing, preventing double-spend while requests await approval. If a request cancels, tokens unlock and return to the user's transferable balance.
    </Tab>
</Tabs>

## Request Workflow System

Commodity Tokens implement four request types that balance automation with compliance oversight:

<CodeGroup>
```typescript Instant Execution
// No approval needed - executes immediately
const requestId = await token.createMintRequest(
    recipientAddress,
    1000e18,          // amount
    1000e18,          // grams added
    RequestType.INSTANT,
    0                 // no timelock
);
// Tokens minted in same transaction
```

```typescript Manual Approval
// Requires issuer approval before execution
const requestId = await token.createMintRequest(
    recipientAddress,
    1000e18,
    1000e18,
    RequestType.MANUAL_APPROVAL,
    0
);
// Later, issuer approves
await token.approveMintRequest(requestId);
// Then anyone executes
await token.executeMintRequest(requestId);
```

```typescript Timelock
// Executes automatically after delay
const requestId = await token.createMintRequest(
    recipientAddress,
    1000e18,
    1000e18,
    RequestType.TIMELOCK,
    86400  // 24 hour delay
);
// After 24 hours pass, anyone can execute
await token.executeMintRequest(requestId);
```

```typescript Conditional (EIP-712)
// Requires off-chain signature from main issuer
const requestId = await token.createMintRequest(
    recipientAddress,
    1000e18,
    1000e18,
    RequestType.CONDITIONAL,
    0
);
// Backend generates EIP-712 signature
const signature = await issuer.signTypedData(domain, types, value);
// Execute with signature proof
await token.executeMintRequestConditional(
    requestId,
    deadline,
    signature.v,
    signature.r,
    signature.s
);
```
</CodeGroup>

This flexibility lets issuers configure workflows that match their operational requirements—high-frequency trading desks use instant execution while banks processing large commodity deliveries implement manual approval with timelock safeguards.

## Fee Distribution

Minting and burning operations can include configurable fees split between the main issuer and the platform. Set `mintFeeBps` and `burnFeeBps` to values between 0-1000 basis points (0-10%).

```typescript
// Configure 0.5% mint fee, 0.25% burn fee
await token.setFees(50, 25); // in basis points

// When user mints 1000 tokens:
// - Total minted: 1000 tokens
// - Fee: 5 tokens (0.5%)
// - User receives: 995 tokens
// - Platform gets: 1.25 tokens (25% of fee)
// - Issuer gets: 3.75 tokens (75% of fee)
```

<Warning>
Fees cannot exceed 10% (1000 bps) to prevent predatory pricing. The platform automatically receives 25% of all collected fees to sustain infrastructure operations.
</Warning>

## Deployment Options

Deploy Commodity Tokens through the Trusset dashboard for guided setup or directly via factory contracts for programmatic control. Both paths generate UUPS upgradeable proxies that share implementation logic while maintaining isolated state.

<Accordion title="Factory Deployment Parameters">
When calling `createCommodityToken` on the factory contract:

- `name` / `symbol`: Token identification
- `gramsPerToken`: Fixed reserve ratio (e.g., 1e18 for 1 gram per token)
- `mainIssuer`: Address with full administrative control
- `redemptionAddress`: Where unredeemed tokens route
- `maxSupply`: Hard cap on total supply (0 = unlimited)
- `kycRequired`: Enforce identity verification on transfers
- `useCustomRegistry`: Override factory default KYC registry
- `customRegistry`: Custom identity registry address (if enabled)

The factory tracks all deployed tokens by issuer, enabling cross-token analytics and consolidated reporting.
</Accordion>

<CardGroup cols={2}>
    <Card title="API Reference" icon="code" href="/api-intro">
        Integration endpoints for Commodity Token deployment
    </Card>
    <Card title="Identity Registry" icon="address-card" href="/new/learn/customers/identity-register">
        KYC verification integration
    </Card>
</CardGroup>
---
title: "Adaptive Interface"
description: "Framework-agnostic APIs that route to asset-specific lending implementations"
---

Adaptive interfaces enable single integration points that work across all lending frameworks. Your application code remains identical whether users borrow against gold tokens, real estate tokens, or stock tokens—backend routing selects appropriate implementations automatically.

## Routing Architecture

The adaptive layer sits between your application and underlying lending frameworks, analyzing collateral types and routing requests to correct implementations:

```typescript
interface AdaptiveRouter {
    // Single endpoint handles all collateral types
    async depositCollateral(
        positionId: number,
        tokenAddress: string,
        amount: bigint
    ): Promise<void>;
    
    // Router determines which framework to use
    private selectFramework(tokenAddress: string): LendingFramework;
}

class LendingRouter implements AdaptiveRouter {
    private frameworks: Map<string, LendingFramework>;
    
    async depositCollateral(
        positionId: number,
        tokenAddress: string,
        amount: bigint
    ): Promise<void> {
        // Determine asset type from token address
        const framework = await this.selectFramework(tokenAddress);
        
        // Route to appropriate implementation
        return framework.depositCollateral(positionId, tokenAddress, amount);
    }
    
    private async selectFramework(
        tokenAddress: string
    ): Promise<LendingFramework> {
        // Query token metadata
        const tokenType = await this.getTokenType(tokenAddress);
        
        // Return matching framework
        switch (tokenType) {
            case 'COMMODITY':
                return this.frameworks.get('commodity');
            case 'REAL_ESTATE':
                return this.frameworks.get('real_estate');
            case 'STOCK':
                return this.frameworks.get('stock');
            default:
                throw new Error('Unsupported token type');
        }
    }
}
```

## Unified API Surface

All lending operations expose through consistent interfaces regardless of underlying framework:

<CodeGroup>
```typescript Position Management
// POST https://api.trusset.org/v1/lending/positions/open
const response = await fetch('https://api.trusset.org/v1/lending/positions/open', {
  method: 'POST',
  headers: {
    'Authorization': `Bearer ${API_KEY}`,
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    marketAddress: "0xLendingMarket" // Router detects market type
  })
});

// Works identically for gold, real estate, or stock markets
```

```typescript Collateral Operations
// POST https://api.trusset.org/v1/lending/collateral/deposit
await fetch('https://api.trusset.org/v1/lending/collateral/deposit', {
  method: 'POST',
  body: JSON.stringify({
    positionId: 42,
    tokenAddress: "0xAnyTokenType", // Auto-routes to correct framework
    amount: "100000000000000000000"
  })
});

// Backend:
// 1. Identifies token type
// 2. Selects appropriate framework
// 3. Validates framework-specific rules
// 4. Executes deposit
```

```typescript Borrowing
// POST https://api.trusset.org/v1/lending/borrow
await fetch('https://api.trusset.org/v1/lending/borrow', {
  method: 'POST',
  body: JSON.stringify({
    positionId: 42,
    amount: "15000000000" 
  })
});

// Returns unified response format:
// {
//   transactionHash: "0x...",
//   borrowedAmount: "15000000000",
//   interestRate: "8.5",
//   healthFactor: "1.67"
// }
```
</CodeGroup>

## Framework Detection

The router identifies appropriate frameworks through multiple detection methods:

<Tabs>
    <Tab title="Token Metadata">
        Query token contracts for type identifiers:

        ```typescript
        async function detectFromMetadata(
            tokenAddress: string
        ): Promise<FrameworkType> {
            const token = new ethers.Contract(
                tokenAddress,
                TOKEN_ABI,
                provider
            );
            
            try {
                // Check for commodity-specific functions
                const gramsPerToken = await token.gramsPerToken();
                if (gramsPerToken > 0n) {
                    return FrameworkType.COMMODITY;
                }
            } catch {}
            
            try {
                // Check for real estate functions
                const propertyAddress = await token.propertyAddress();
                if (propertyAddress) {
                    return FrameworkType.REAL_ESTATE;
                }
            } catch {}
            
            try {
                // Check for stock functions
                const stockISIN = await token.stockISIN();
                if (stockISIN) {
                    return FrameworkType.STOCK;
                }
            } catch {}
            
            throw new Error('Unknown token type');
        }
        ```
    </Tab>
    
    <Tab title="Registry Lookup">
        Maintain central registry mapping tokens to frameworks:

        ```typescript
        class FrameworkRegistry {
            private registry: Map<string, FrameworkType>;
            
            async registerToken(
                tokenAddress: string,
                frameworkType: FrameworkType
            ) {
                this.registry.set(
                    tokenAddress.toLowerCase(),
                    frameworkType
                );
            }
            
            getFramework(tokenAddress: string): FrameworkType {
                const type = this.registry.get(
                    tokenAddress.toLowerCase()
                );
                
                if (!type) {
                    throw new Error('Token not registered');
                }
                
                return type;
            }
        }
        ```
    </Tab>
    
    <Tab title="Market Configuration">
        Let markets declare supported token types during deployment:

        ```typescript
        interface MarketConfig {
            address: string;
            frameworkType: FrameworkType;
            supportedCollateral: string[];
        }
        
        async function getMarketFramework(
            marketAddress: string
        ): Promise<FrameworkType> {
            const market = new ethers.Contract(
                marketAddress,
                MARKET_ABI,
                provider
            );
            
            // Query market for framework identifier
            const frameworkId = await market.FRAMEWORK_TYPE();
            
            return frameworkId;
        }
        ```
    </Tab>
</Tabs>

## Response Normalization

Different frameworks return varying data structures—the adaptive layer normalizes responses into consistent formats:

```typescript
interface NormalizedPosition {
    positionId: number;
    borrower: string;
    collateral: CollateralInfo[];
    debt: DebtInfo;
    health: HealthInfo;
    framework: FrameworkType;
}

class ResponseNormalizer {
    normalize(
        rawResponse: any,
        framework: FrameworkType
    ): NormalizedPosition {
        switch (framework) {
            case FrameworkType.COMMODITY:
                return this.normalizeCommodity(rawResponse);
            case FrameworkType.REAL_ESTATE:
                return this.normalizeRealEstate(rawResponse);
            case FrameworkType.STOCK:
                return this.normalizeStock(rawResponse);
        }
    }
    
    private normalizeCommodity(raw: any): NormalizedPosition {
        return {
            positionId: raw.id,
            borrower: raw.borrower,
            collateral: raw.collateralTokens.map((token, i) => ({
                address: token,
                amount: raw.collateralAmounts[token],
                value: raw.collateralValues[i],
                // Commodity-specific fields
                gramsPerToken: raw.gramsPerToken,
                totalGrams: raw.totalGramsReserve
            })),
            debt: {
                principal: raw.borrowedAmount,
                interest: raw.accumulatedInterest,
                total: raw.borrowedAmount + raw.accumulatedInterest,
                apr: raw.currentAPR
            },
            health: {
                factor: raw.healthFactor,
                liquidationThreshold: raw.liquidationThreshold,
                status: this.getHealthStatus(raw.healthFactor)
            },
            framework: FrameworkType.COMMODITY
        };
    }
}
```

## Multi-Framework Positions

Users can hold positions across multiple frameworks simultaneously—the adaptive interface aggregates data:

```typescript
async function getUserPortfolio(
    userAddress: string
): Promise<Portfolio> {
    const allMarkets = await this.getDeployedMarkets();
    const positions: NormalizedPosition[] = [];
    
    // Query each market for user positions
    for (const market of allMarkets) {
        const framework = await this.getMarketFramework(market.address);
        const userPositions = await this.getUserPositions(
            market.address,
            userAddress
        );
        
        // Normalize and aggregate
        positions.push(
            ...userPositions.map(p => 
                this.normalizer.normalize(p, framework)
            )
        );
    }
    
    return {
        user: userAddress,
        positions: positions,
        aggregates: this.calculateAggregates(positions)
    };
}

interface Portfolio {
    user: string;
    positions: NormalizedPosition[];
    aggregates: {
        totalCollateralValue: bigint;
        totalDebtValue: bigint;
        weightedHealthFactor: number;
        totalInterestPaid: bigint;
    };
}
```

## Framework-Specific Features

Some operations only exist in certain frameworks—the adaptive layer handles gracefully:

<Accordion title="Optional Feature Handling">
```typescript
interface OptionalFeatures {
    // Commodity-specific
    updateReserveAttestation?(
        positionId: number,
        totalGrams: bigint,
        attestationURI: string
    ): Promise<void>;
    
    // Real estate-specific
    updatePropertyValuation?(
        positionId: number,
        newValuation: bigint,
        appraisalURI: string
    ): Promise<void>;
    
    // Stock-specific
    handleCorporateAction?(
        positionId: number,
        actionType: string,
        actionData: any
    ): Promise<void>;
}

class AdaptiveFramework implements OptionalFeatures {
    async updateReserveAttestation(
        positionId: number,
        totalGrams: bigint,
        attestationURI: string
    ): Promise<void> {
        const framework = await this.getPositionFramework(positionId);
        
        if (framework === FrameworkType.COMMODITY) {
            // Feature exists - execute
            return this.commodityFramework.updateReserveAttestation(
                positionId,
                totalGrams,
                attestationURI
            );
        } else {
            throw new Error(
                'Reserve attestation only available for commodity tokens'
            );
        }
    }
}
```
</Accordion>

## SDK Implementation

Client-side SDK abstracts framework complexity completely:

```typescript
import { TrussetLending } from '@trusset/sdk';

const lending = new TrussetLending({
    apiKey: process.env.TRUSSET_API_KEY,
    network: 'mainnet'
});

// Works with any token type
const position = await lending.openPosition();

await lending.depositCollateral(
    position.id,
    goldTokenAddress, // Or real estate, or stock
    ethers.parseEther('100')
);

await lending.borrow(
    position.id,
    ethers.parseUnits('15000', 6) // USDC
);

// SDK handles framework detection automatically
const health = await lending.getHealthFactor(position.id);
console.log(`Health: ${ethers.formatUnits(health, 18)}`);
```

## Error Handling

Standardize error responses across frameworks:

```typescript
enum LendingErrorCode {
    INSUFFICIENT_COLLATERAL = 'INSUFFICIENT_COLLATERAL',
    POSITION_UNHEALTHY = 'POSITION_UNHEALTHY',
    MARKET_PAUSED = 'MARKET_PAUSED',
    UNSUPPORTED_COLLATERAL = 'UNSUPPORTED_COLLATERAL',
    ORACLE_STALE = 'ORACLE_STALE'
}

interface NormalizedError {
    code: LendingErrorCode;
    message: string;
    framework: FrameworkType;
    details: any;
}

class ErrorNormalizer {
    normalize(error: any, framework: FrameworkType): NormalizedError {
        // Map framework-specific errors to standard codes
        const errorCode = this.mapErrorCode(error, framework);
        
        return {
            code: errorCode,
            message: this.getReadableMessage(errorCode),
            framework: framework,
            details: error
        };
    }
}
```

## Caching Strategy

Cache framework detection and market configurations to minimize redundant queries:

```typescript
class FrameworkCache {
    private cache: Map<string, CacheEntry>;
    private TTL = 3600000; // 1 hour
    
    async getFramework(tokenAddress: string): Promise<FrameworkType> {
        const cached = this.cache.get(tokenAddress);
        
        if (cached && Date.now() - cached.timestamp < this.TTL) {
            return cached.framework;
        }
        
        // Cache miss - fetch and store
        const framework = await this.detectFramework(tokenAddress);
        
        this.cache.set(tokenAddress, {
            framework: framework,
            timestamp: Date.now()
        });
        
        return framework;
    }
}
```

<Warning>
The adaptive interface adds minimal latency (typically less than 50ms) while simplifying integration significantly. For ultra-low-latency applications, consider direct framework integration bypassing the routing layer.
</Warning>

<CardGroup cols={2}>
    <Card title="Lending Frameworks" icon="layer-group" href="/new/learn/lending/frameworks">
        Asset-specific implementation details
    </Card>
    <Card title="API Reference" icon="code" href="/api-intro">
        Complete endpoint documentation
    </Card>
    <Card title="Calculations" icon="calculator" href="/new/learn/lending/advanced/calculations">
        Mathematical formulas across frameworks
    </Card>
    <Card title="Cross-Instance Liquidity" icon="arrows-left-right" href="/new/learn/lending/advanced/cross-instance">
        Multi-institution lending integration
    </Card>
</CardGroup>